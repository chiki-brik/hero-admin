// slice - срез => кусочек функционала, который будет включаться в store
import {createApi, fetchBaseQuery} from '@reduxjs/toolkit/query/react';

// создаем базовый функционал, чтобы работать с сервером
// createApi - автоматически генерирует react-хуки на каждое наше действие
// как формируется название хука: use (регулярная приставка) + GetHeroes (endpoint) + Query/Mutation (тип endpoint)
// api нужно добавить в store, чтобы его там "зарегистрировать". createApi создает еще и reducer, который будет в нашем state формировать свойство 'api', куда все будет помещаться
export const apiSlice = createApi({ // apiSlice - объект
    reducerPath: 'api', // название нашего reducer(части, которая будет отвечать за изменение state). То есть все наши данные будут помещены в store.api. state + reducer = store. 
    // если этот параметр не задавать автоматически будет поставлена эта строка - api
    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001'}),// обязательное поле. По факту это метод - сюда помещаем функцию, которая будет делать запрос
    // baseUrl - куда мы будем делать запросы по-умолчанию
    tagTypes: ['Heroes'], // типы тэгов. Нужно чтобы автоматизировать обновление данных сервера, при обновлении их со стороны клиента(добавлении/удалении). Метки, с помощью которых будем связывать функции, чтобы при выполнении одной сразу выполнялась другая. Что именно загрузить повторно, когда данные изменились?
    endpoints: builder => ({ // builder - встроенный объект, которые позволяет конструировать reducer при помощи встроенных в него методов
        getHeroes: builder.query({ // эти действия правильнее называть endpoint
            query: () => '/heroes',
            providesTags: ['Heroes']
        }),
        createHero: builder.mutation({
            query: hero => ({
                url: '/heroes', // где мутация проводится
                method: 'POST', // когда будет вызываться этот хук, какой метод будет использоваться
                body: hero // тело запроса. body будет автоматически превращен в json-формат
            }),
            invalidatesTags: ['Heroes']
        }),
        deleteHero: builder.mutation({
            query: id => ({
                url: `/heroes/${id}`,
                method: 'DELETE'
            }),
            invalidatesTags: ['Heroes']
        })
    })// обязательное поле. По факту это метод - принимает в себя функцию. Это те операции, которые мы будем проводить по базовому адресу(получение данных, отправка данных, удаление, обновление)
    // тут будет два типа действий
    // 1 - query - запросы, которые получают данные и сохраняют их
    // 2 - mutation - запросы на изменение данных на сервере
    // 
});

export const {useGetHeroesQuery, useCreateHeroMutation, useDeleteHeroMutation} = apiSlice;